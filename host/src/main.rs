// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use std::env;
use std::fs::File;
use std::io::Write;
use std::io::Read;

use methods::{
    FHE_GUEST_ELF, FHE_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

use fhe_traits::{FheDecoder, FheEncoder, FheEncrypter, FheDecrypter, Serialize, DeserializeParametrized};
use fhe::bfv::{BfvParametersBuilder, Ciphertext, Encoding, Plaintext, PublicKey, SecretKey, BfvParameters};
use rand::{rngs::OsRng, thread_rng};

#[derive(serde::Serialize, serde::Deserialize)]
struct FheParam {
    ciphtxt1: Vec<u8>,
    ciphtxt2: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct KeyPair{
  sk: Vec<u8>,
  pk: Vec<u8>
}

#[macro_use] extern crate rocket;
use rocket::serde::json::Json;

#[get("/generateKeyPair")]
fn generateKeyPair() -> String {
  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();
 
  let secret_key = SecretKey::random(&parameters, &mut OsRng);
  let public_key = PublicKey::new(&secret_key, &mut rng);

  /*@dev Write to local files
  let mut file = File::create("pkey.json").unwrap();
  let serialized_pk = serde_json::to_vec(&public_key.to_bytes()).unwrap();
  file.write(&serialized_pk);

  file = File::create("skey.json").unwrap();
  let serialized_sk = serde_json::to_vec(&secret_key.to_bytes()).unwrap();
  file.write(&serialized_sk); */

  let key_pair = KeyPair { sk: secret_key.to_bytes(), pk: public_key.to_bytes() };
  let serialized_key_pair = serde_json::to_string(&key_pair).unwrap();
  serialized_key_pair
}

#[derive(rocket::serde::Serialize, rocket::serde::Deserialize)]
#[serde(crate = "rocket::serde")]
struct EncryptionWrapper {
  key: Vec<u8>,
  plaintext: u64
}

#[post("/encrypt", format="json", data="<public_key>")]
fn encrypt(public_key: Json<EncryptionWrapper>) -> Vec<u8> {
  let pkey = &public_key.key;
  let plaintext = public_key.plaintext;

  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();

  /*@dev Read from a local file
  let mut file = File::open("pkey.json").unwrap();
  let mut ser_pk = String::new();
  file.read_to_string(&mut ser_pk).unwrap();
  let pkey: Vec<u8>= serde_json::from_str(&ser_pk).unwrap();*/
  
  let public_key = PublicKey::from_bytes(&pkey, &parameters).unwrap();

  let plaintext_encoded = Plaintext::try_encode(&[plaintext], Encoding::poly(), &parameters).unwrap();
  let ciphertext = PublicKey::try_encrypt(&public_key, &plaintext_encoded, &mut rng).unwrap();

  /*@dev Write to a local file
  let mut file = File::create("cipher.json").unwrap();
  file.write(&serialized_cipher); */

  let serialized_cipher = serde_json::to_vec(&ciphertext.to_bytes()).unwrap();
  serialized_cipher
}

#[get("/decrypt")]
fn decrypt() -> Vec<u8>{
  let parameters = BfvParameters::default_arc(1, 8);

  let mut file = File::open("skey.json").unwrap();
    let mut ser_sk = String::new();
    file.read_to_string(&mut ser_sk).unwrap();
    let skey: Vec<u8>= serde_json::from_str(&ser_sk).unwrap();
    let secret_key = SecretKey::from_bytes(&skey, &parameters).unwrap();

  file = File::open("cipher.json").unwrap();
    let mut ser_c = String::new();
    file.read_to_string(&mut ser_c).unwrap();
    let ciph: Vec<u8>= serde_json::from_str(&ser_c).unwrap();
    let ciphertext_1 = Ciphertext::from_bytes(&ciph, &parameters).unwrap();

    let decrypted_plaintext = SecretKey::try_decrypt(&secret_key, &ciphertext_1).unwrap();
    let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();

    // Verify the result was correct
    println!("decrypted_vector[0] {}", decrypted_vector[0]);
    // bincode::serialize(&decrypted_vector).unwrap()
    let serialized_r = serde_json::to_vec(&decrypted_vector).unwrap();
    serialized_r
}

#[launch]
fn rocket() -> _ {
  env::set_var("RISC0_DEV_MODE", "1");

  rocket::build().mount("/", routes![generateKeyPair, encrypt, decrypt])
}

// fn main() {
//     env::set_var("RISC0_DEV_MODE", "1");

//     let parameters = BfvParametersBuilder::new()
//       .set_degree(2048)
//       .set_moduli(&[0x3fffffff000001])
//       .set_plaintext_modulus(1 << 10)
//       .build_arc().unwrap();
//     let mut rng = thread_rng();

//     let secret_key = SecretKey::random(&parameters, &mut OsRng);
//     let public_key = PublicKey::new(&secret_key, &mut rng);

//     let plaintext_1 = Plaintext::try_encode(&[20_u64], Encoding::poly(), &parameters).unwrap();
//     let plaintext_2 = Plaintext::try_encode(&[7_u64], Encoding::poly(), &parameters).unwrap();

//     let ciphertext_1: Ciphertext = secret_key.try_encrypt(&plaintext_1, &mut rng).unwrap();
//     let ciphertext_2: Ciphertext = public_key.try_encrypt(&plaintext_2, &mut rng).unwrap();

//     let fhe_params = FheParam { ciphtxt1: ciphertext_1.to_bytes(), ciphtxt2: ciphertext_2.to_bytes() };

//     let env = ExecutorEnv::builder()
//       .write_slice(&bincode::serialize(&fhe_params).unwrap())
//       .build().unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Produce a receipt by proving the specified ELF binary.
//     let receipt = prover.prove_elf(env, FHE_GUEST_ELF).unwrap();

//     // Deserialize resulting ciphertext
//     let result: Vec<u8> = receipt.journal.decode().unwrap();
//     let ciph_out: Ciphertext = Ciphertext::from_bytes(&result, &parameters).unwrap();

//     receipt.verify(FHE_GUEST_ID).unwrap();

//     let decrypted_plaintext = secret_key.try_decrypt(&ciph_out).unwrap();
//     let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();

//     // Verify the result was correct
//     assert_eq!(decrypted_vector[0], 27);
// }
