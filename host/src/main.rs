use std::env;
use std::fs::File;
use std::io::Write;
use std::io::Read;

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    FHE_GUEST_ELF, FHE_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

// FHE
use fhe_traits::{FheDecoder, FheEncoder, FheEncrypter, FheDecrypter, Serialize, DeserializeParametrized};
use fhe::bfv::{BfvParametersBuilder, Ciphertext, Encoding, Plaintext, PublicKey, SecretKey, BfvParameters};
use rand::{rngs::OsRng, thread_rng};

#[derive(serde::Serialize, serde::Deserialize)]
struct KeyPair{
  sk: Vec<u8>,
  pk: Vec<u8>
}

#[macro_use] extern crate rocket;
use rocket::serde::json::Json;

#[get("/generateKeyPair")]
fn generate_key_pair() -> String {
  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();
 
  let secret_key = SecretKey::random(&parameters, &mut OsRng);
  let public_key = PublicKey::new(&secret_key, &mut rng);

  /*@dev Write to local files
  let mut file = File::create("pkey.json").unwrap();
  let serialized_pk = serde_json::to_vec(&public_key.to_bytes()).unwrap();
  file.write(&serialized_pk);

  file = File::create("skey.json").unwrap();
  let serialized_sk = serde_json::to_vec(&secret_key.to_bytes()).unwrap();
  file.write(&serialized_sk); */

  let key_pair = KeyPair { sk: secret_key.to_bytes(), pk: public_key.to_bytes() };
  let serialized_key_pair = serde_json::to_string(&key_pair).unwrap();
  serialized_key_pair
}

// Encryption on demand

#[derive(rocket::serde::Serialize, rocket::serde::Deserialize)]
#[serde(crate = "rocket::serde")]
struct EncryptionWrapper {
  key: Vec<u8>,
  plaintext: u64
}

#[post("/encrypt", format="json", data="<encryption_params>")]
fn encrypt(encryption_params: Json<EncryptionWrapper>) -> Vec<u8> {
  let pkey = &encryption_params.key;
  let plaintext = encryption_params.plaintext;

  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();

  /*@dev Read from a local file
  let mut file = File::open("pkey.json").unwrap();
  let mut ser_pk = String::new();
  file.read_to_string(&mut ser_pk).unwrap();
  let pkey: Vec<u8>= serde_json::from_str(&ser_pk).unwrap();*/
  
  let public_key = PublicKey::from_bytes(&pkey, &parameters).unwrap();

  let plaintext_encoded = Plaintext::try_encode(&[plaintext], Encoding::poly(), &parameters).unwrap();
  let ciphertext = PublicKey::try_encrypt(&public_key, &plaintext_encoded, &mut rng).unwrap();

  /*@dev Write to a local file
  let mut file = File::create("cipher.json").unwrap();
  file.write(&serialized_cipher); */

  let serialized_cipher = serde_json::to_vec(&ciphertext.to_bytes()).unwrap();
  serialized_cipher
}

// Decryption on demand

#[derive(rocket::serde::Serialize, rocket::serde::Deserialize)]
#[serde(crate = "rocket::serde")]
struct DecryptionWrapper {
  key: Vec<u8>,
  ciphertext: Vec<u8>
}

#[post("/decrypt", format="json", data="<decryption_params>")]
fn decrypt(decryption_params: Json<DecryptionWrapper>) -> Vec<u8>{
  let secret_key_vec = &decryption_params.key;
  let ciphertext_vec = &decryption_params.ciphertext;

  let parameters = BfvParameters::default_arc(1, 8);

  /*@dev Read from a local file
  let mut file = File::open("skey.json").unwrap();
  let mut ser_sk = String::new();
  file.read_to_string(&mut ser_sk).unwrap();
  let skey: Vec<u8>= serde_json::from_str(&ser_sk).unwrap();
  */
  
  /*@dev Read from a local file
  file = File::open("cipher.json").unwrap();
  let mut ser_c = String::new();
  file.read_to_string(&mut ser_c).unwrap();
  let ciph: Vec<u8>= serde_json::from_str(&ser_c).unwrap();
  */

  let secret_key = SecretKey::from_bytes(&secret_key_vec, &parameters).unwrap();
  let ciphertext = Ciphertext::from_bytes(&ciphertext_vec, &parameters).unwrap();

  let decrypted_plaintext = SecretKey::try_decrypt(&secret_key, &ciphertext).unwrap();
  let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();
  println!("decrypted_result {}", decrypted_vector[0]);

  let serialized_value = serde_json::to_vec(&decrypted_vector).unwrap();
  serialized_value
}

// FHE operations

#[derive(serde::Serialize, serde::Deserialize)]
struct FhePayParam {
    sender_cipher_balance: Vec<u8>,
    ciphertext_amount_sender: Vec<u8>,
    receiver_cipher_balance: Vec<u8>,
    ciphertext_amount_receiver: Vec<u8>
}

#[derive(serde::Serialize, serde::Deserialize)]
struct FhePayResult {
  sender_cipher_balance: Vec<u8>,
  receiver_cipher_balance: Vec<u8>
}

#[derive(rocket::serde::Serialize, rocket::serde::Deserialize)]
#[serde(crate = "rocket::serde")]
struct FhePayWrapper {
  sender_pk: Vec<u8>,
  sender_cipher_balance: Vec<u8>,
  receiver_pk: Vec<u8>,
  receiver_cipher_balance: Vec<u8>,
  plaintext_amount: u64
}

#[post("/fhe_pay", format="json", data="<fhe_wrapper>")]
fn fhe_pay(fhe_wrapper: Json<FhePayWrapper>) -> Vec<u8>{
  let sender_pk = &fhe_wrapper.sender_pk;
  let sender_cipher_balance = &fhe_wrapper.sender_cipher_balance;
  let receiver_pk = &fhe_wrapper.receiver_pk;
  let receiver_cipher_balance = &fhe_wrapper.receiver_cipher_balance;
  let plaintext_amount = fhe_wrapper.plaintext_amount;

  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();

  let sender_public_key = PublicKey::from_bytes(&sender_pk, &parameters).unwrap();
  let receiver_public_key = PublicKey::from_bytes(&receiver_pk, &parameters).unwrap();

  let sender_cipher_balance = Ciphertext::from_bytes(&sender_cipher_balance, &parameters).unwrap();
  let receiver_cipher_balance = Ciphertext::from_bytes(&receiver_cipher_balance, &parameters).unwrap();
  
  let plaintext_amount_encoded = Plaintext::try_encode(&[plaintext_amount], Encoding::poly(), &parameters).unwrap();
  let ciphertext_amount_sender = PublicKey::try_encrypt(&sender_public_key, &plaintext_amount_encoded, &mut rng).unwrap();
  let ciphertext_amount_receiver = PublicKey::try_encrypt(&receiver_public_key, &plaintext_amount_encoded, &mut rng).unwrap();

  let fhe_pay_params = FhePayParam { 
    sender_cipher_balance: sender_cipher_balance.to_bytes(), 
    ciphertext_amount_sender: ciphertext_amount_sender.to_bytes(), 
    receiver_cipher_balance: receiver_cipher_balance.to_bytes(), 
    ciphertext_amount_receiver: ciphertext_amount_receiver.to_bytes() 
  };

  // Verifiable computation
  let env = ExecutorEnv::builder()
    .write_slice(&bincode::serialize(&fhe_pay_params).unwrap())
    .build().unwrap();

  // Obtain the default prover.
  let prover = default_prover();
  // Produce a receipt by proving the specified ELF binary.
  let receipt = prover.prove_elf(env, FHE_GUEST_ELF).unwrap();
  // Deserialize resulting ciphertext
  let result: Vec<u8> = receipt.journal.decode().unwrap();
  // Verify the receipt
  receipt.verify(FHE_GUEST_ID).unwrap();

  let fhe_pay_result: FhePayResult = bincode::deserialize(&result).unwrap();
  let serialized_fhe_pay_result = serde_json::to_vec(&fhe_pay_result).unwrap();
  serialized_fhe_pay_result
}

#[launch]
fn rocket() -> _ {
  env::set_var("RISC0_DEV_MODE", "1");

  rocket::build().mount("/", routes![generate_key_pair, encrypt, decrypt, fhe_pay])
}

// fn main() {
//     env::set_var("RISC0_DEV_MODE", "1");

//     let parameters = BfvParametersBuilder::new()
//       .set_degree(2048)
//       .set_moduli(&[0x3fffffff000001])
//       .set_plaintext_modulus(1 << 10)
//       .build_arc().unwrap();
//     let mut rng = thread_rng();

//     let secret_key = SecretKey::random(&parameters, &mut OsRng);
//     let public_key = PublicKey::new(&secret_key, &mut rng);

//     let plaintext_1 = Plaintext::try_encode(&[20_u64], Encoding::poly(), &parameters).unwrap();
//     let plaintext_2 = Plaintext::try_encode(&[7_u64], Encoding::poly(), &parameters).unwrap();

//     let ciphertext_1: Ciphertext = secret_key.try_encrypt(&plaintext_1, &mut rng).unwrap();
//     let ciphertext_2: Ciphertext = public_key.try_encrypt(&plaintext_2, &mut rng).unwrap();

//     let fhe_params = FheParam { ciphtxt1: ciphertext_1.to_bytes(), ciphtxt2: ciphertext_2.to_bytes() };

//     let env = ExecutorEnv::builder()
//       .write_slice(&bincode::serialize(&fhe_params).unwrap())
//       .build().unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Produce a receipt by proving the specified ELF binary.
//     let receipt = prover.prove_elf(env, FHE_GUEST_ELF).unwrap();

//     // Deserialize resulting ciphertext
//     let result: Vec<u8> = receipt.journal.decode().unwrap();
//     let ciph_out: Ciphertext = Ciphertext::from_bytes(&result, &parameters).unwrap();

//     receipt.verify(FHE_GUEST_ID).unwrap();

//     let decrypted_plaintext = secret_key.try_decrypt(&ciph_out).unwrap();
//     let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();

//     // Verify the result was correct
//     assert_eq!(decrypted_vector[0], 27);
// }
