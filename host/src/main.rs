// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use std::env;
use std::fs::File;
use std::io::Write;
use std::io::Read;

use methods::{
    FHE_GUEST_ELF, FHE_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};

use fhe_traits::{FheDecoder, FheEncoder, FheEncrypter, FheDecrypter, Serialize, DeserializeParametrized};
use fhe::bfv::{BfvParametersBuilder, Ciphertext, Encoding, Plaintext, PublicKey, SecretKey, BfvParameters};
use rand::{rngs::OsRng, thread_rng};

#[derive(serde::Serialize, serde::Deserialize)]
struct FheParam {
    ciphtxt1: Vec<u8>,
    ciphtxt2: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct KeyPair{
  sk: Vec<u8>,
  pk: Vec<u8>
}

#[macro_use] extern crate rocket;

#[get("/generateKeyPair")]
fn generateKeyPair() -> Vec<u8> {
  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();
 
  let secret_key = SecretKey::random(&parameters, &mut OsRng);
  let public_key = PublicKey::new(&secret_key, &mut rng);

  let mut file = File::create("pkey.json").unwrap();
  let serialized_pk = serde_json::to_vec(&public_key.to_bytes()).unwrap();
  file.write(&serialized_pk);

  file = File::create("skey.json").unwrap();
  let serialized_sk = serde_json::to_vec(&secret_key.to_bytes()).unwrap();
  file.write(&serialized_sk);

  let key_pair = KeyPair { sk: secret_key.to_bytes(), pk: public_key.to_bytes() };
  bincode::serialize(&key_pair).unwrap()
}

#[get("/encrypt")]
fn encrypt() -> Vec<u8> {
  let parameters = BfvParameters::default_arc(1, 8);
  let mut rng = thread_rng();

  let mut file = File::open("pkey.json").unwrap();
  let mut ser_pk = String::new();
  file.read_to_string(&mut ser_pk).unwrap();
  let pkey: Vec<u8>= serde_json::from_str(&ser_pk).unwrap();
  
  let public_key = PublicKey::from_bytes(&pkey, &parameters).unwrap();

  let plaintext_1 = Plaintext::try_encode(&[20_u64], Encoding::poly(), &parameters).unwrap();
  let ciphertext_1 = PublicKey::try_encrypt(&public_key, &plaintext_1, &mut rng).unwrap();

//   let mut file = File::create("cipher.json").unwrap();
// let serialized_c = serde_json::to_vec(&ciphertext_1.to_bytes()).unwrap();
// file.write(&serialized_c);

    bincode::serialize(&ciphertext_1.to_bytes()).unwrap()
}

#[get("/decrypt")]
fn decrypt() -> Vec<u8>{
  let parameters = BfvParameters::default_arc(1, 8);

  let mut file = File::open("skey.json").unwrap();
    let mut ser_sk = String::new();
    file.read_to_string(&mut ser_sk).unwrap();
    let skey: Vec<u8>= serde_json::from_str(&ser_sk).unwrap();
    let secret_key = SecretKey::from_bytes(&skey, &parameters).unwrap();

  file = File::open("cipher.json").unwrap();
    let mut ser_c = String::new();
    file.read_to_string(&mut ser_c).unwrap();
    let ciph: Vec<u8>= serde_json::from_str(&ser_c).unwrap();
    let ciphertext_1 = Ciphertext::from_bytes(&ciph, &parameters).unwrap();

    let decrypted_plaintext = SecretKey::try_decrypt(&secret_key, &ciphertext_1).unwrap();
    let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();

    // Verify the result was correct
    println!("decrypted_vector[0] {}", decrypted_vector[0]);
    bincode::serialize(&decrypted_vector).unwrap()
}

#[launch]
fn rocket() -> _ {
  env::set_var("RISC0_DEV_MODE", "1");

  rocket::build().mount("/", routes![generateKeyPair, encrypt, decrypt])
}

// fn main() {
//     env::set_var("RISC0_DEV_MODE", "1");

//     let parameters = BfvParametersBuilder::new()
//       .set_degree(2048)
//       .set_moduli(&[0x3fffffff000001])
//       .set_plaintext_modulus(1 << 10)
//       .build_arc().unwrap();
//     let mut rng = thread_rng();

//     let secret_key = SecretKey::random(&parameters, &mut OsRng);
//     let public_key = PublicKey::new(&secret_key, &mut rng);

//     let plaintext_1 = Plaintext::try_encode(&[20_u64], Encoding::poly(), &parameters).unwrap();
//     let plaintext_2 = Plaintext::try_encode(&[7_u64], Encoding::poly(), &parameters).unwrap();

//     let ciphertext_1: Ciphertext = secret_key.try_encrypt(&plaintext_1, &mut rng).unwrap();
//     let ciphertext_2: Ciphertext = public_key.try_encrypt(&plaintext_2, &mut rng).unwrap();

//     let fhe_params = FheParam { ciphtxt1: ciphertext_1.to_bytes(), ciphtxt2: ciphertext_2.to_bytes() };

//     let env = ExecutorEnv::builder()
//       .write_slice(&bincode::serialize(&fhe_params).unwrap())
//       .build().unwrap();

//     // Obtain the default prover.
//     let prover = default_prover();

//     // Produce a receipt by proving the specified ELF binary.
//     let receipt = prover.prove_elf(env, FHE_GUEST_ELF).unwrap();

//     // Deserialize resulting ciphertext
//     let result: Vec<u8> = receipt.journal.decode().unwrap();
//     let ciph_out: Ciphertext = Ciphertext::from_bytes(&result, &parameters).unwrap();

//     receipt.verify(FHE_GUEST_ID).unwrap();

//     let decrypted_plaintext = secret_key.try_decrypt(&ciph_out).unwrap();
//     let decrypted_vector = Vec::<i64>::try_decode(&decrypted_plaintext, Encoding::poly()).unwrap();

//     // Verify the result was correct
//     assert_eq!(decrypted_vector[0], 27);
// }
